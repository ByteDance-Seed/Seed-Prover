-- In HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Basic.lean

/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute
import Mathlib.Algebra.RingQuot
import Mathlib.RingTheory.TwoSidedIdeal.Operations
/-!

# Field operator algebra

-/

namespace FieldSpecification
open FieldOpFreeAlgebra
open HepLean.List
open FieldStatistic

variable (𝓕 : FieldSpecification)

/-- The set contains the super-commutators equal to zero in the operator algebra.
  This contains e.g. the super-commutator of two creation operators. -/
def fieldOpIdealSet : Set (FieldOpFreeAlgebra 𝓕) :=
  { x |
    (∃ (φ1 φ2 φ3 : 𝓕.CrAnFieldOp),
        x = [ofCrAnOpF φ1, [ofCrAnOpF φ2, ofCrAnOpF φ3]ₛca]ₛca)
    ∨ (∃ (φc φc' : 𝓕.CrAnFieldOp) (_ : 𝓕 |>ᶜ φc = .create) (_ : 𝓕 |>ᶜ φc' = .create),
      x = [ofCrAnOpF φc, ofCrAnOpF φc']ₛca)
    ∨ (∃ (φa φa' : 𝓕.CrAnFieldOp) (_ : 𝓕 |>ᶜ φa = .annihilate) (_ : 𝓕 |>ᶜ φa' = .annihilate),
      x = [ofCrAnOpF φa, ofCrAnOpF φa']ₛca)
    ∨ (∃ (φ φ' : 𝓕.CrAnFieldOp) (_ : ¬ (𝓕 |>ₛ φ) = (𝓕 |>ₛ φ')),
      x = [ofCrAnOpF φ, ofCrAnOpF φ']ₛca)}

/-- For a field specification `𝓕`, the algebra `𝓕.FieldOpAlgebra` is defined as the quotient
  of the free algebra `𝓕.FieldOpFreeAlgebra` by the ideal generated by
- `[ofCrAnOpF φc, ofCrAnOpF φc']ₛca` for `φc` and `φc'` field creation operators.
  This corresponds to the condition that two creation operators always super-commute.
- `[ofCrAnOpF φa, ofCrAnOpF φa']ₛca` for `φa` and `φa'` field annihilation operators.
  This corresponds to the condition that two annihilation operators always super-commute.
- `[ofCrAnOpF φ, ofCrAnOpF φ']ₛca` for `φ` and `φ'` operators with different statistics.
  This corresponds to the condition that two operators with different statistics always
  super-commute. In other words, fermions and bosons always super-commute.
- `[ofCrAnOpF φ1, [ofCrAnOpF φ2, ofCrAnOpF φ3]ₛca]ₛca`. This corresponds to the condition,
  when combined with the conditions above, that the super-commutator is in the center of the
  of the algebra.
-/
abbrev FieldOpAlgebra : Type := (TwoSidedIdeal.span 𝓕.fieldOpIdealSet).ringCon.Quotient

namespace FieldOpAlgebra
variable {𝓕 : FieldSpecification}

/-- The instance of a setoid on `FieldOpFreeAlgebra` from the ideal `TwoSidedIdeal`. -/
instance : Setoid (FieldOpFreeAlgebra 𝓕) := (TwoSidedIdeal.span 𝓕.fieldOpIdealSet).ringCon.toSetoid

lemma equiv_iff_sub_mem_ideal (x y : FieldOpFreeAlgebra 𝓕) :
    x ≈ y ↔ x - y ∈ TwoSidedIdeal.span 𝓕.fieldOpIdealSet := by
  rw [← TwoSidedIdeal.rel_iff]
  rfl

lemma equiv_iff_exists_add (x y : FieldOpFreeAlgebra 𝓕) :
    x ≈ y ↔ ∃ a, x = y + a ∧ a ∈ TwoSidedIdeal.span 𝓕.fieldOpIdealSet := by
  apply Iff.intro
  · intro h
    rw [equiv_iff_sub_mem_ideal] at h
    use x - y
    simp [h]
  · intro h
    obtain ⟨a, rfl, ha⟩ := h
    rw [equiv_iff_sub_mem_ideal]
    simp [ha]

/-- For a field specification `𝓕`, the projection

`𝓕.FieldOpFreeAlgebra →ₐ[ℂ] FieldOpAlgebra 𝓕`

taking each element of `𝓕.FieldOpFreeAlgebra` to its equivalence class in `FieldOpAlgebra 𝓕`. -/
def ι : FieldOpFreeAlgebra 𝓕 →ₐ[ℂ] FieldOpAlgebra 𝓕 where
  toFun := (TwoSidedIdeal.span 𝓕.fieldOpIdealSet).ringCon.mk'
  map_one' := by rfl
  map_mul' x y := by rfl
  map_zero' := by rfl
  map_add' x y := by rfl
  commutes' x := by rfl

lemma ι_surjective : Function.Surjective (@ι 𝓕) := by
  intro x
  obtain ⟨x⟩ := x
  use x
  rfl

lemma ι_apply (x : FieldOpFreeAlgebra 𝓕) : ι x = Quotient.mk _ x := rfl

lemma ι_of_mem_fieldOpIdealSet (x : FieldOpFreeAlgebra 𝓕) (hx : x ∈ 𝓕.fieldOpIdealSet) :
    ι x = 0 := by
  rw [ι_apply]
  change ⟦x⟧ = ⟦0⟧
  simp only [ringConGen, Quotient.eq]
  refine RingConGen.Rel.of x 0 ?_
  simpa using hx

lemma ι_superCommuteF_of_create_create (φc φc' : 𝓕.CrAnFieldOp) (hφc : 𝓕 |>ᶜ φc = .create)
    (hφc' : 𝓕 |>ᶜ φc' = .create) : ι [ofCrAnOpF φc, ofCrAnOpF φc']ₛca = 0 := by
  apply ι_of_mem_fieldOpIdealSet
  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]
  simp only [exists_prop]
  right
  left
  use φc, φc', hφc, hφc'

lemma ι_superCommuteF_of_annihilate_annihilate (φa φa' : 𝓕.CrAnFieldOp)
    (hφa : 𝓕 |>ᶜ φa = .annihilate) (hφa' : 𝓕 |>ᶜ φa' = .annihilate) :
    ι [ofCrAnOpF φa, ofCrAnOpF φa']ₛca = 0 := by
  apply ι_of_mem_fieldOpIdealSet
  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]
  simp only [exists_prop]
  right
  right
  left
  use φa, φa', hφa, hφa'

lemma ι_superCommuteF_of_diff_statistic {φ ψ : 𝓕.CrAnFieldOp}
    (h : (𝓕 |>ₛ φ) ≠ (𝓕 |>ₛ ψ)) : ι [ofCrAnOpF φ, ofCrAnOpF ψ]ₛca = 0 := by
  apply ι_of_mem_fieldOpIdealSet
  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]
  right
  right
  right
  use φ, ψ

lemma ι_superCommuteF_zero_of_fermionic (φ ψ : 𝓕.CrAnFieldOp)
    (h : [ofCrAnOpF φ, ofCrAnOpF ψ]ₛca ∈ statisticSubmodule fermionic) :
    ι [ofCrAnOpF φ, ofCrAnOpF ψ]ₛca = 0 := by
  rw [← ofCrAnListF_singleton, ← ofCrAnListF_singleton] at h ⊢
  rcases statistic_neq_of_superCommuteF_fermionic h with h | h
  · simp only [ofCrAnListF_singleton]
    apply ι_superCommuteF_of_diff_statistic
    simpa using h
  · simp [h]

lemma ι_superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_zero (φ ψ : 𝓕.CrAnFieldOp) :
    [ofCrAnOpF φ, ofCrAnOpF ψ]ₛca ∈ statisticSubmodule bosonic ∨
    ι [ofCrAnOpF φ, ofCrAnOpF ψ]ₛca = 0 := by
  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [φ] [ψ] with h | h
  · simp_all [ofCrAnListF_singleton]
  · simp_all only [ofCrAnListF_singleton]
    right
    exact ι_superCommuteF_zero_of_fermionic _ _ h

/-!

## Super-commutes are in the center

-/

@[simp]
lemma ι_superCommuteF_ofCrAnOpF_superCommuteF_ofCrAnOpF_ofCrAnOpF (φ1 φ2 φ3 : 𝓕.CrAnFieldOp) :
    ι [ofCrAnOpF φ1, [ofCrAnOpF φ2, ofCrAnOpF φ3]ₛca]ₛca = 0 := by
  apply ι_of_mem_fieldOpIdealSet
  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]
  left
  use φ1, φ2, φ3

lemma ι_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnOpF (φ1 φ2 φ3 : 𝓕.CrAnFieldOp) :
    ι [[ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca, ofCrAnOpF φ3]ₛca = 0 := by
  rw [← ofCrAnListF_singleton, ← ofCrAnListF_singleton, ← ofCrAnListF_singleton]
  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [φ1] [φ2] with h | h
  · rw [bonsonic_superCommuteF_symm h]
    simp [ofCrAnListF_singleton]
  · rcases ofCrAnListF_bosonic_or_fermionic [φ3] with h' | h'
    · rw [superCommuteF_bonsonic_symm h']
      simp [ofCrAnListF_singleton]
    · rw [superCommuteF_fermionic_fermionic_symm h h']
      simp [ofCrAnListF_singleton]

lemma ι_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnListF (φ1 φ2 : 𝓕.CrAnFieldOp)
    (φs : List 𝓕.CrAnFieldOp) :
    ι [[ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca, ofCrAnListF φs]ₛca = 0 := by
  rw [← ofCrAnListF_singleton, ← ofCrAnListF_singleton]
  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [φ1] [φ2] with h | h
  · rw [superCommuteF_bosonic_ofCrAnListF_eq_sum _ _ h]
    simp [ofCrAnListF_singleton, ι_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnOpF]
  · rw [superCommuteF_fermionic_ofCrAnListF_eq_sum _ _ h]
    simp [ofCrAnListF_singleton, ι_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnOpF]

@[simp]
lemma ι_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_fieldOpFreeAlgebra (φ1 φ2 : 𝓕.CrAnFieldOp)
    (a : 𝓕.FieldOpFreeAlgebra) : ι [[ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca, a]ₛca = 0 := by
  change (ι.toLinearMap ∘ₗ superCommuteF [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) a = _
  have h1 : (ι.toLinearMap ∘ₗ superCommuteF [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) = 0 := by
    apply (ofCrAnListFBasis.ext fun l ↦ ?_)
    simp [ι_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnListF]
  rw [h1]
  simp

/- Start of proof attempt -/
lemma round1_h_main (𝓕 : FieldSpecification)
  (φ1 φ2 : 𝓕.CrAnFieldOp)
  (a : 𝓕.FieldOpFreeAlgebra):
  ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * ι a - ι a * ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca = 0 := by
  have h_or : [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca ∈ statisticSubmodule bosonic ∨ ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca = 0 := by
    exact ι_superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_zero φ1 φ2
  cases h_or with
  | inl h1 =>
    -- Case 1: [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca ∈ statisticSubmodule bosonic
    have h2 : [[ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca, a]ₛca = [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * a - a * [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca := by
      have h_bosonic : [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca ∈ statisticSubmodule bosonic := h1
      exact?
    have h3 : ι [[ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca, a]ₛca = 0 := by
      exact ι_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_fieldOpFreeAlgebra φ1 φ2 a
    have h4 : ι ([ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * a - a * [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) = 0 := by
      rw [h2] at h3
      exact h3
    have h5 : ι ([ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * a) - ι (a * [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) = 0 := by
      have h51 : ι ([ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * a - a * [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) = ι ([ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * a) - ι (a * [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) := by
        rw [map_sub]
        <;> rfl
      rw [h51] at h4
      exact h4
    have h52 : ι ([ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * a) = ι ([ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) * ι a := by
      rw [map_mul]
      <;> rfl
    have h53 : ι (a * [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) = ι a * ι ([ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) := by
      rw [map_mul]
      <;> rfl
    rw [h52, h53] at h5
    exact h5
  | inr h2 =>
    -- Case 2: ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca = 0
    have h21 : ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca = 0 := h2
    calc
      ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * ι a - ι a * ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca
        = 0 * ι a - ι a * 0 := by rw [h21]
      _ = 0 := by simp [mul_zero, zero_mul, sub_self]

lemma round1_main (𝓕 : FieldSpecification)
  (φ1 φ2 : 𝓕.CrAnFieldOp)
  (a : 𝓕.FieldOpFreeAlgebra)
  (h_main : ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * ι a - ι a * ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca = 0):
  ι a * ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca - ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * ι a = 0 := by
  have h : ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * ι a - ι a * ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca = 0 := h_main
  have h6 : ι a * ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca - ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * ι a = - (ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * ι a - ι a * ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca) := by
    ring_nf
    <;> abel
  rw [h6]
  rw [h]
  simp

theorem ι_commute_fieldOpFreeAlgebra_superCommuteF_ofCrAnOpF_ofCrAnOpF (φ1 φ2 : 𝓕.CrAnFieldOp)
    (a : 𝓕.FieldOpFreeAlgebra) : ι a * ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca -
    ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * ι a = 0  := by

  have h_main : ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca * ι a - ι a * ι [ofCrAnOpF φ1, ofCrAnOpF φ2]ₛca = 0 := by
    exact round1_h_main 𝓕 φ1 φ2 a
  exact round1_main 𝓕 φ1 φ2 a h_main
