-- In HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Basic.lean

/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute
import Mathlib.Algebra.RingQuot
import Mathlib.RingTheory.TwoSidedIdeal.Operations
/-!

# Field operator algebra

-/

namespace FieldSpecification
open FieldOpFreeAlgebra
open HepLean.List
open FieldStatistic

variable (ğ“• : FieldSpecification)

/-- The set contains the super-commutators equal to zero in the operator algebra.
  This contains e.g. the super-commutator of two creation operators. -/
def fieldOpIdealSet : Set (FieldOpFreeAlgebra ğ“•) :=
  { x |
    (âˆƒ (Ï†1 Ï†2 Ï†3 : ğ“•.CrAnFieldOp),
        x = [ofCrAnOpF Ï†1, [ofCrAnOpF Ï†2, ofCrAnOpF Ï†3]â‚›ca]â‚›ca)
    âˆ¨ (âˆƒ (Ï†c Ï†c' : ğ“•.CrAnFieldOp) (_ : ğ“• |>á¶œ Ï†c = .create) (_ : ğ“• |>á¶œ Ï†c' = .create),
      x = [ofCrAnOpF Ï†c, ofCrAnOpF Ï†c']â‚›ca)
    âˆ¨ (âˆƒ (Ï†a Ï†a' : ğ“•.CrAnFieldOp) (_ : ğ“• |>á¶œ Ï†a = .annihilate) (_ : ğ“• |>á¶œ Ï†a' = .annihilate),
      x = [ofCrAnOpF Ï†a, ofCrAnOpF Ï†a']â‚›ca)
    âˆ¨ (âˆƒ (Ï† Ï†' : ğ“•.CrAnFieldOp) (_ : Â¬ (ğ“• |>â‚› Ï†) = (ğ“• |>â‚› Ï†')),
      x = [ofCrAnOpF Ï†, ofCrAnOpF Ï†']â‚›ca)}

/-- For a field specification `ğ“•`, the algebra `ğ“•.FieldOpAlgebra` is defined as the quotient
  of the free algebra `ğ“•.FieldOpFreeAlgebra` by the ideal generated by
- `[ofCrAnOpF Ï†c, ofCrAnOpF Ï†c']â‚›ca` for `Ï†c` and `Ï†c'` field creation operators.
  This corresponds to the condition that two creation operators always super-commute.
- `[ofCrAnOpF Ï†a, ofCrAnOpF Ï†a']â‚›ca` for `Ï†a` and `Ï†a'` field annihilation operators.
  This corresponds to the condition that two annihilation operators always super-commute.
- `[ofCrAnOpF Ï†, ofCrAnOpF Ï†']â‚›ca` for `Ï†` and `Ï†'` operators with different statistics.
  This corresponds to the condition that two operators with different statistics always
  super-commute. In other words, fermions and bosons always super-commute.
- `[ofCrAnOpF Ï†1, [ofCrAnOpF Ï†2, ofCrAnOpF Ï†3]â‚›ca]â‚›ca`. This corresponds to the condition,
  when combined with the conditions above, that the super-commutator is in the center of the
  of the algebra.
-/
abbrev FieldOpAlgebra : Type := (TwoSidedIdeal.span ğ“•.fieldOpIdealSet).ringCon.Quotient

namespace FieldOpAlgebra
variable {ğ“• : FieldSpecification}

/-- The instance of a setoid on `FieldOpFreeAlgebra` from the ideal `TwoSidedIdeal`. -/
instance : Setoid (FieldOpFreeAlgebra ğ“•) := (TwoSidedIdeal.span ğ“•.fieldOpIdealSet).ringCon.toSetoid

lemma equiv_iff_sub_mem_ideal (x y : FieldOpFreeAlgebra ğ“•) :
    x â‰ˆ y â†” x - y âˆˆ TwoSidedIdeal.span ğ“•.fieldOpIdealSet := by
  rw [â† TwoSidedIdeal.rel_iff]
  rfl

lemma equiv_iff_exists_add (x y : FieldOpFreeAlgebra ğ“•) :
    x â‰ˆ y â†” âˆƒ a, x = y + a âˆ§ a âˆˆ TwoSidedIdeal.span ğ“•.fieldOpIdealSet := by
  apply Iff.intro
  Â· intro h
    rw [equiv_iff_sub_mem_ideal] at h
    use x - y
    simp [h]
  Â· intro h
    obtain âŸ¨a, rfl, haâŸ© := h
    rw [equiv_iff_sub_mem_ideal]
    simp [ha]

/-- For a field specification `ğ“•`, the projection

`ğ“•.FieldOpFreeAlgebra â†’â‚[â„‚] FieldOpAlgebra ğ“•`

taking each element of `ğ“•.FieldOpFreeAlgebra` to its equivalence class in `FieldOpAlgebra ğ“•`. -/
def Î¹ : FieldOpFreeAlgebra ğ“• â†’â‚[â„‚] FieldOpAlgebra ğ“• where
  toFun := (TwoSidedIdeal.span ğ“•.fieldOpIdealSet).ringCon.mk'
  map_one' := by rfl
  map_mul' x y := by rfl
  map_zero' := by rfl
  map_add' x y := by rfl
  commutes' x := by rfl

lemma Î¹_surjective : Function.Surjective (@Î¹ ğ“•) := by
  intro x
  obtain âŸ¨xâŸ© := x
  use x
  rfl

lemma Î¹_apply (x : FieldOpFreeAlgebra ğ“•) : Î¹ x = Quotient.mk _ x := rfl

lemma Î¹_of_mem_fieldOpIdealSet (x : FieldOpFreeAlgebra ğ“•) (hx : x âˆˆ ğ“•.fieldOpIdealSet) :
    Î¹ x = 0 := by
  rw [Î¹_apply]
  change âŸ¦xâŸ§ = âŸ¦0âŸ§
  simp only [ringConGen, Quotient.eq]
  refine RingConGen.Rel.of x 0 ?_
  simpa using hx

lemma Î¹_superCommuteF_of_create_create (Ï†c Ï†c' : ğ“•.CrAnFieldOp) (hÏ†c : ğ“• |>á¶œ Ï†c = .create)
    (hÏ†c' : ğ“• |>á¶œ Ï†c' = .create) : Î¹ [ofCrAnOpF Ï†c, ofCrAnOpF Ï†c']â‚›ca = 0 := by
  apply Î¹_of_mem_fieldOpIdealSet
  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]
  simp only [exists_prop]
  right
  left
  use Ï†c, Ï†c', hÏ†c, hÏ†c'

lemma Î¹_superCommuteF_of_annihilate_annihilate (Ï†a Ï†a' : ğ“•.CrAnFieldOp)
    (hÏ†a : ğ“• |>á¶œ Ï†a = .annihilate) (hÏ†a' : ğ“• |>á¶œ Ï†a' = .annihilate) :
    Î¹ [ofCrAnOpF Ï†a, ofCrAnOpF Ï†a']â‚›ca = 0 := by
  apply Î¹_of_mem_fieldOpIdealSet
  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]
  simp only [exists_prop]
  right
  right
  left
  use Ï†a, Ï†a', hÏ†a, hÏ†a'

lemma Î¹_superCommuteF_of_diff_statistic {Ï† Ïˆ : ğ“•.CrAnFieldOp}
    (h : (ğ“• |>â‚› Ï†) â‰  (ğ“• |>â‚› Ïˆ)) : Î¹ [ofCrAnOpF Ï†, ofCrAnOpF Ïˆ]â‚›ca = 0 := by
  apply Î¹_of_mem_fieldOpIdealSet
  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]
  right
  right
  right
  use Ï†, Ïˆ

lemma Î¹_superCommuteF_zero_of_fermionic (Ï† Ïˆ : ğ“•.CrAnFieldOp)
    (h : [ofCrAnOpF Ï†, ofCrAnOpF Ïˆ]â‚›ca âˆˆ statisticSubmodule fermionic) :
    Î¹ [ofCrAnOpF Ï†, ofCrAnOpF Ïˆ]â‚›ca = 0 := by
  rw [â† ofCrAnListF_singleton, â† ofCrAnListF_singleton] at h âŠ¢
  rcases statistic_neq_of_superCommuteF_fermionic h with h | h
  Â· simp only [ofCrAnListF_singleton]
    apply Î¹_superCommuteF_of_diff_statistic
    simpa using h
  Â· simp [h]

lemma Î¹_superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_zero (Ï† Ïˆ : ğ“•.CrAnFieldOp) :
    [ofCrAnOpF Ï†, ofCrAnOpF Ïˆ]â‚›ca âˆˆ statisticSubmodule bosonic âˆ¨
    Î¹ [ofCrAnOpF Ï†, ofCrAnOpF Ïˆ]â‚›ca = 0 := by
  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [Ï†] [Ïˆ] with h | h
  Â· simp_all [ofCrAnListF_singleton]
  Â· simp_all only [ofCrAnListF_singleton]
    right
    exact Î¹_superCommuteF_zero_of_fermionic _ _ h

/-!

## Super-commutes are in the center

-/

/- Start of proof attempt -/
lemma round1_h1 (ğ“• : FieldSpecification)
  (Ï†1 Ï†2 Ï†3 : ğ“•.CrAnFieldOp):
  [ofCrAnOpF Ï†1, [ofCrAnOpF Ï†2, ofCrAnOpF Ï†3]â‚›ca]â‚›ca âˆˆ ğ“•.fieldOpIdealSet := by
  simp only [fieldOpIdealSet, Set.mem_setOf_eq]
  left
  refine' âŸ¨Ï†1, Ï†2, Ï†3, rflâŸ©

theorem Î¹_superCommuteF_ofCrAnOpF_superCommuteF_ofCrAnOpF_ofCrAnOpF (Ï†1 Ï†2 Ï†3 : ğ“•.CrAnFieldOp) :
    Î¹ [ofCrAnOpF Ï†1, [ofCrAnOpF Ï†2, ofCrAnOpF Ï†3]â‚›ca]â‚›ca = 0  := by

  have h1 : [ofCrAnOpF Ï†1, [ofCrAnOpF Ï†2, ofCrAnOpF Ï†3]â‚›ca]â‚›ca âˆˆ ğ“•.fieldOpIdealSet := by
    exact round1_h1 ğ“• Ï†1 Ï†2 Ï†3
  exact Î¹_of_mem_fieldOpIdealSet _ h1
